Дней на выполнение: 4

result: 92/100

1) **Сильные стороны**
- Создана таблица Students с точным соответствием требуемым полям, включая ограничения (PRIMARY KEY, UNIQUE).
- Данные корректно вставлены, включая студентов на курсе "Программирование" и на другом курсе для проверки фильтрации.
- Запрос возвращает имена студентов, записанных на курс "Программирование", что соответствует основной цели задания.
- Код чистый, хорошо отформатирован, имена столбцов понятны.

2) **Ошибки и недочёты**

**Блокирующие (ломает выполнение требований задания)**
- Нет.

**Значимые (может дать неверный результат на части кейсов, сильно ухудшает качество)**
- Вложенный запрос избыточен и не имеет практического смысла. Внутренний подзапрос `SELECT id FROM Students WHERE course_name = "Программирование"` возвращает те же id, что уже отфильтрованы внешним условием `WHERE course_name = "Программирование"`. Это не соответствует духу задания "с помощью вложенного запроса", хотя технически запрос является вложенным. Задание предполагает использование вложенного запроса для фильтрации, но здесь он не выполняет новой логики. Это можно считать неоптимальным, но не приводит к неверным результатам на предоставленных данных.

**Минорные (стиль, читаемость, мелкие улучшения без влияния на правильность)**
- Использование `DROP TABLE Students` без проверки существования таблицы может вызвать ошибку при первом запуске, если таблицы нет. В условии это не запрещено, но лучше добавить `IF EXISTS` для устойчивости: `DROP TABLE IF EXISTS Students;`.
- Формат дат в INSERT ("03-11-1992") нестандартен для SQLite (рекомендуется YYYY-MM-DD). SQLite может интерпретировать это, но возможны проблемы с сортировкой и сравнением. В условии не указан обязательный формат, но для надёжности стоит использовать ISO 8601.
- В задании курс называется «Программирование» (с кавычками-ёлочками в описании), в коде использованы прямые двойные кавычки — это допустимо в SQLite, но лучше придерживаться единообразия.

3) **Оценка и как она посчитана**
- Функциональность и соответствие условию: 46/50 (минус 4 за избыточный вложенный запрос, который не демонстрирует типичное применение вложенного запроса для фильтрации по связанным данным, хотя технически требования формально выполнены).
- Качество кода (структура, читаемость, устойчивость, отсутствие дублирования): 28/30 (минус 2 за потенциальную ошибку при DROP TABLE и нестандартный формат дат, что может снизить надёжность).
- Стиль и тесты: 18/20 (код хорошо структурирован, но нет комментариев или пояснений; тесты не требовались, поэтому штраф минимален).
Итог: 92/100.

4) **Если задание выполнено не полностью**
Задание выполнено полностью: создана таблица, добавлены данные, выполнен вложенный запрос. Однако вложенный запрос можно улучшить, чтобы он был более осмысленным. Например, если бы была отдельная таблица Courses, вложенный запрос мог бы выбирать id курса "Программирование", а внешний запрос — студентов с этим course_id. В текущей структуре (одна таблица) более уместен простой запрос без вложенности: `SELECT name FROM Students WHERE course_name = 'Программирование';`. Но так как задание требует именно вложенного запроса, можно предложить альтернативу, которая всё же демонстрирует его полезность (хотя и искусственно):

**Вариант улучшенного вложенного запроса для текущей структуры:**
```sql
SELECT name 
FROM Students 
WHERE id IN (
    SELECT id 
    FROM Students 
    WHERE course_name = 'Программирование'
);
```
Это убирает дублирование условия во внешнем запросе и делает вложенный запрос осмысленным как отдельный фильтр.
