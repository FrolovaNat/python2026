Время затраченное на выполнение: 1:33

result: 50/100

1) **Сильные стороны**
- Созданы таблицы `Customers` и `Orders` с полями, соответствующими описанию.
- Вставлены демонстрационные данные, совпадающие с примером.
- Выполнен первый запрос (INNER JOIN) для получения перечня клиентов с их заказами, что соответствует Уровню 1.
- Предпринята попытка выполнить запросы для Уровня 2 (LEFT JOIN и UNION).

2) **Ошибки и недочёты**

**Блокирующие (ломает выполнение требований задания)**
- **Уровень 1: Нарушение схемы данных.** В таблице `Orders` поле `Customer_ID` объявлено как `PRIMARY KEY` (строка `"Customer_ID" INTEGER PRIMARY KEY`). Это не соответствует псевдокоду условия, где `CustomerID` является целочисленной ссылкой (внешним ключом), а `OrderID` — автоинкрементным первичным ключом. Это делает невозможным добавление нескольких заказов для одного клиента, ломая логику данных. Исправление: убрать `PRIMARY KEY` с `Customer_ID` и добавить его к `Order_ID`, а также добавить объявление внешнего ключа.
- **Уровень 3: Задание не выполнено.** Отсутствует запрос для нахождения заказов, для которых нет соответствующего клиента. В решении есть только `SELECT * FROM Orders`, который не решает поставленную задачу.

**Значимые (может дать неверный результат на части кейсов, сильно ухудшает качество)**
- **Отсутствие объявления автоинкремента и внешнего ключа.** В условии для Уровня 1 явно указаны автоувеличение для идентификаторов и связь внешнего ключа. В решении этого нет (`AUTOINCREMENT` для SQLite и `FOREIGN KEY`). Это не является строго блокирующим для демонстрации, но существенно снижает соответствие условию.
- **Уровень 2, запрос B (UNION): Неверный порядок и типы полей.** В UNION-запросе поля `FirstName` и `LastName` в первой части и `Order_ID`, `TotalAmount` во второй части выбраны в разном порядке относительно ожидаемого вывода (имя, фамилия, номер заказа, сумма). Это приведёт к путанице в результирующем наборе. Кроме того, использование `NULL` корректно, но итоговый список не является "единым перечнем клиентов и заказов" в смысле объединения строк, так как разделяет данные.

**Минорные (стиль, читаемость, мелкие улучшения без влияния на правильность)**
- Использование `DROP TABLE` без условия `IF EXISTS` может вызвать ошибку при первом запуске (в SQLite это допустимо, но лучше добавить для переносимости).
- Имена столбцов в кавычках и с подчёркиванием (`Customer_ID`) вместо указанных в условии (`CustomerID`) — не ошибка, но снижает соответствие псевдокоду.
- В конце файла присутствуют лишние операторы `SELECT*FROM Customers;` и `SELECT*FROM Orders;`, которые не требуются по условию.

3) **Оценка и как она посчитана**
- **Функциональность и соответствие условию: 25/50**
    - Уровень 1: Создание таблиц и вставка данных +10, INNER JOIN +5. Минус 10 за критическую ошибку в схеме (PRIMARY KEY не на том поле, нет внешнего ключа и автоинкремента).
    - Уровень 2: LEFT JOIN выполнен +5, UNION выполнен, но с логическими недостатками +3. Минус 2 за некорректный порядок полей в UNION.
    - Уровень 3: Задание не выполнено, 0 баллов.
- **Качество кода (структура, читаемость, устойчивость, отсутствие дублирования): 15/30**
    - Структура последовательная, но есть лишние операторы SELECT. Читаемость средняя (смешение стилей именования). Устойчивость низкая из-за ошибки в PRIMARY KEY. Дублирования нет.
- **Стиль и тесты: 10/20**
    - Стиль: имена столбцов не полностью соответствуют условию, использование кавычек избыточно. Форматирование можно улучшить (пробелы вокруг операторов). Тесты не требовались и не предоставлены.
- **Итог: 25 + 15 + 10 = 50/100.**

4) **Если задание выполнено не полностью**
- **Отсутствует:** Корректная реализация Уровня 3 (поиск заказов без клиентов).
- **Выполнено частично:** Уровень 2, запрос B (UNION) выводит данные, но не в том формате, который, вероятно, подразумевался (объединение записей, а не полей).

**Вариант полного решения (исправления и дополнения):**
```sql
-- Исправление Уровня 1: Создание таблиц с автоинкрементом и внешним ключом
CREATE TABLE IF NOT EXISTS Customers (
    CustomerID INTEGER PRIMARY KEY AUTOINCREMENT,
    FirstName TEXT,
    LastName TEXT,
    Email TEXT
);

CREATE TABLE IF NOT EXISTS Orders (
    OrderID INTEGER PRIMARY KEY AUTOINCREMENT,
    CustomerID INTEGER,
    OrderDate TEXT,
    TotalAmount REAL,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

-- Вставка данных (как в решении студента, но с именами полей как в CREATE TABLE)
INSERT INTO Customers (CustomerID, FirstName, LastName, Email) VALUES
(1, 'John', 'Doe', 'johndoe@example.com'),
(2, 'Jane', 'Smith', 'janesmith@example.com');

INSERT INTO Orders (OrderID, CustomerID, OrderDate, TotalAmount) VALUES
(101, 1, '2025-02-01', 100.50),
(102, 2, '2025-02-02', 200.75);

-- Уровень 1: Перечень клиентов с заказами
SELECT Customers.FirstName, Customers.LastName, Orders.OrderID, Orders.TotalAmount
FROM Customers
INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID;

-- Уровень 2, запрос A: Клиенты, даже без заказов (LEFT JOIN)
SELECT Customers.FirstName, Customers.LastName, Orders.OrderID, Orders.TotalAmount
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;

-- Уровень 2, запрос B: Единый перечень (UNION ALL для объединения строк)
-- Выводим клиентов как записи с пустыми заказами и заказы как записи с пустыми клиентами
SELECT FirstName, LastName, NULL AS OrderID, NULL AS TotalAmount FROM Customers
UNION ALL
SELECT NULL, NULL, OrderID, TotalAmount FROM Orders;

-- Уровень 3: Заказы, для которых нет соответствующего клиента
-- Используем LEFT JOIN и фильтр IS NULL
SELECT Orders.OrderID, Orders.CustomerID, Orders.OrderDate, Orders.TotalAmount
FROM Orders
LEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID
WHERE Customers.CustomerID IS NULL;
```
