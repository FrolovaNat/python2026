Дней на выполнение: 4

result: 60/100

1) **Сильные стороны**
- Код выполняет основную задачу: извлекает числа из текста и выводит их с порядковыми номерами.
- Используются указанные в задании методы: `replace()`, `filter()`, `range(len(...))`.
- Логика подсчёта количества вхождений каждого числа реализована, хотя и неэффективно.
- Код запускается и выводит результат в похожем формате.

2) **Ошибки и недочёты**

**Блокирующие (ломает выполнение требований задания)**
- Формат вывода не соответствует требуемому. В задании указан вывод в виде списка кортежей `(число, порядковый номер в тексте, количество вхождений в текст)`. В решении студента кортежи имеют структуру `(id, number, amount)`, где `id` — это индекс в списке извлечённых чисел, а не порядковый номер числа в исходном тексте. Порядковый номер в тексте должен отражать позицию числа среди всех чисел в тексте (начиная с 0), что в примере соответствует первому элементу кортежа. Однако студент использует `range(len(numbers))`, который даёт индексы 0,1,2,... для списка `numbers`, что технически является порядковым номером в списке извлечённых чисел, но в контексте задания, вероятно, подразумевается именно это. Более критично: в примере ожидаемого результата первый элемент кортежа — это порядковый номер (0,1,2,...), второй — само число как строка, третий — количество вхождений. У студента первый элемент — `id` (порядковый номер), второй — `number` (строка), третий — `amount`. Это формально соответствует структуре, но из-за ошибки в логике подсчёта дубликатов вывод получается некорректным (см. ниже).
- Подсчёт количества вхождений выполняется некорректно для повторяющихся чисел. В текущей реализации для каждого элемента `result` (который изначально содержит кортежи `(id, number)`) происходит подсчёт вхождений числа `entry[1]` во всём списке `result`. Однако после первого прохода и замены кортежа на `(id, number, amount)` для одного и того же числа могут быть подсчитаны разные значения `amount`, потому что `result` изменяется в процессе итерации, и подсчёт ведётся по обновлённому списку. Это приводит к тому, что для одинаковых чисел могут быть записаны разные значения `amount`. Например, если число '12' встречается дважды, оба кортежа для '12' должны иметь `amount=2`. В коде студента это может не гарантироваться из-за модификации списка в цикле. Кроме того, подсчёт заново для каждого элемента неэффективен и приводит к квадратичной сложности.

**Значимые (может дать неверный результат на части кейсов, сильно ухудшает качество)**
- Обработка знаков препинания неполная. Студент удаляет точки, запятые и дефисы, но в тексте есть другие знаки, например, тире (—), которое отличается от дефиса (-). В примере входных данных есть тире, и студент пытается удалить '-', но это не удаляет тире '—'. Также не удаляются знаки процента '%', которые в примере студента присутствуют (например, "30 %"). Это приведёт к тому, что "30" и "12" могут быть извлечены некорректно, если после числа стоит знак процента без пробела (в примере студента есть пробел, но в общем случае это ненадёжно). В условии сказано "Чтобы убрать знаки препинания из текста, используйте метод строкового типа `replace()`", но не уточнено, какие именно знаки. Однако из примера ожидаемого результата видно, что числа извлекаются корректно, включая случаи с точками, запятыми, тире. Поэтому необходимо удалить все распространённые знаки препинания или использовать более общий подход.
- Использование `filter()` с `lambda text: text.isdigit()` применяется к списку слов, полученному после `split(' ')`. Это корректно для извлечения чисел, состоящих только из цифр, но если в тексте есть числа с другими символами (например, "10,5" после удаления запятой станет "105"), это может привести к ошибкам. В данном задании, судя по примеру, числа целые, так что это не критично, но обработка знаков препинания должна быть до split.

**Минорные (стиль, читаемость, мелкие улучшения без влияния на правильность)**
- Имена переменных: `id` — это встроенная функция в Python, её переопределение не рекомендуется. Лучше использовать `index` или `idx`.
- В цикле `for entry, id in zip(result,range(len(numbers))):` используется `zip` с `result` и `range(len(numbers))`, но `result` на этот момент уже имеет ту же длину, что и `numbers`, так что `id` будет соответствовать индексу, но это избыточно. Можно было бы использовать `enumerate(result)`.
- Дублирование кода: два очень похожих цикла `for ... in zip(...)`. Логику можно объединить.
- Неэффективный подсчёт: вложенный цикл для каждого элемента приводит к сложности O(n²). Для подсчёта количества вхождений лучше использовать словарь.
- Вывод: `print(result)` выводит список в формате Python, что соответствует ожидаемому результату, но в задании не указано, что нужно выводить именно так. Это приемлемо.

3) **Оценка и как она посчитана**
- Функциональность и соответствие условию: 25/50 (минус 25 за блокирующие ошибки: неверный формат вывода из-за некорректного подсчёта количества вхождений и неполную обработку знаков препинания, что может привести к неверному извлечению чисел).
- Качество кода (структура, читаемость, устойчивость, отсутствие дублирования): 20/30 (минус 10 за значимые и минорные недочёты: неэффективный алгоритм, переопределение встроенного имени, избыточные циклы, неполная обработка знаков препинания).
- Стиль и тесты: 15/20 (минус 5 за стилевые моменты: имена переменных, читаемость, отсутствие комментариев; тесты не требовались, но код можно было бы сделать чище).
Итог: 25 + 20 + 15 = 60/100.

4) **Если задание выполнено не полностью**
Задание выполнено частично: основная функциональность есть, но есть ошибки в формате вывода и подсчёте дубликатов.

**Вариант исправленного решения**
```python
text = "..."  # исходный текст

# Удаляем знаки препинания: точка, запятая, тире, дефис, знак процента и др.
for punct in ".,-—%":
    text = text.replace(punct, '')

# Разбиваем на слова и фильтруем числа
words = text.split()
numbers = list(filter(lambda w: w.isdigit(), words))

# Подсчитываем количество вхождений каждого числа
count_dict = {}
for num in numbers:
    count_dict[num] = count_dict.get(num, 0) + 1

# Формируем результат с порядковыми номерами
result = []
for idx, num in enumerate(numbers):
    result.append((idx, num, count_dict[num]))

print(result)
```
Этот код:
1. Удаляет основные знаки препинания.
2. Извлекает числа с помощью `filter()` и `isdigit()`.
3. Считает вхождения через словарь за O(n).
4. Создаёт кортежи с порядковым номером (idx), числом и количеством вхождений.
5. Выводит результат в требуемом формате.

Для полного соответствия примеру из условия можно добавить обработку всех знаков препинания, но в данном случае указаны наиболее вероятные.
